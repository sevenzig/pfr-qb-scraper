# NFL QB Scraper Development Rules for Cursor AI
# Comprehensive rules for script-to-CLI migration and ongoing development

## PROJECT OVERVIEW
This project scrapes NFL quarterback data from Pro Football Reference and stores it in a PostgreSQL database using Supabase. Currently undergoing migration from scattered scripts to a unified CLI architecture.

## MIGRATION PROCESS GUARDRAILS

### Phase Compliance Rules
- NEVER skip migration phases - follow Foundation → Core → Data → Polish sequence
- ALWAYS maintain backwards compatibility until Phase 4 deprecation
- NEVER break existing scripts during Phases 1-3
- ALWAYS test each phase deliverable before proceeding to next phase
- NEVER merge code without passing the phase-specific success criteria

### Architecture Compliance
- ALL new code must go in proper module structure (src/cli/, src/core/, src/operations/)
- NEVER put business logic in CLI command handlers
- ALWAYS use dependency injection patterns for testability
- NEVER create circular dependencies between modules
- ALWAYS follow single responsibility principle for classes and functions

### Migration-Specific Patterns
- NEW CLI commands must inherit from BaseCommand class
- ALL scrapers must extend the unified CoreScraper class
- NEVER duplicate existing functionality - consolidate instead
- ALWAYS use the new configuration system (src/config/settings.py)
- NEVER hardcode values - use configuration management

## PYTHON CODE QUALITY STANDARDS

### Code Style & Structure
- Follow PEP 8 style guidelines strictly
- Use type hints for all function parameters and return values
- Prefer dataclasses over dictionaries for structured data
- Use f-strings for string formatting
- Keep functions focused and under 50 lines when possible
- Use descriptive variable names (avoid abbreviations)

### Type Safety Requirements
- ALL functions must have complete type hints (args, returns, variables)
- NEVER use 'any' type - use Union, Optional, or specific types
- ALWAYS import from typing module properly
- ALL dataclasses must use proper type annotations
- NEVER skip type checking - must pass mypy validation

### Error Handling Standards
- NEVER use bare except clauses - always specify exception types
- ALWAYS provide contextual error messages with relevant data
- NEVER suppress errors silently - log and handle appropriately
- ALL API calls must have proper retry logic with exponential backoff
- ALWAYS use custom exception classes for domain-specific errors
- Implement proper retry logic with exponential backoff
- Handle rate limiting gracefully

### Documentation Requirements
- ALL public functions must have comprehensive docstrings
- ALWAYS include Args, Returns, Raises sections in docstrings
- NEVER omit examples in docstrings for complex functions
- ALL classes must have class-level docstrings explaining purpose
- ALWAYS update module-level docstrings when adding new functionality
- Document complex algorithms and business logic
- Add inline comments for non-obvious code sections

### Data Processing
- Validate all scraped data before database insertion
- Use pandas for data manipulation when appropriate
- Implement data cleaning functions with clear names
- Handle missing/null values explicitly
- Use safe type conversion functions (safe_int, safe_float)
- Validate data ranges and constraints

### Web Scraping Best Practices
- Respect robots.txt and rate limits
- Use appropriate User-Agent headers
- Implement proper request timeouts
- Handle HTTP errors and retries
- Cache responses when appropriate
- Monitor and log request statistics
- ALL scrapers must implement proper rate limiting (minimum 2 seconds between requests)
- NEVER make concurrent requests without permission
- ALL scraping operations must be resumable for long runs

## SQL CODE QUALITY STANDARDS

### Schema Design Rules
- ALL tables must have proper primary keys (prefer PFR IDs)
- ALWAYS use appropriate data types (DECIMAL for money, TIMESTAMP for dates)
- NEVER use VARCHAR without length limits
- ALL foreign keys must have proper CASCADE/RESTRICT rules
- ALWAYS include meaningful constraints (CHECK, UNIQUE, NOT NULL)
- Add meaningful indexes for query performance
- Use descriptive table and column names
- Include comments on tables and complex columns
- Design for both OLTP and OLAP workloads

### Query Standards
- ALL queries must use parameterized statements (no string concatenation)
- NEVER use SELECT * in production code
- ALWAYS use proper JOIN syntax (no comma joins)
- ALL complex queries must have EXPLAIN plans validated
- NEVER commit queries without proper indexing consideration
- Use LIMIT for potentially large result sets
- Prefer JOINs over subqueries when possible
- Include proper WHERE clause ordering

### Migration Safety
- ALL schema changes must be backwards compatible during migration
- NEVER drop tables during Phases 1-3 - only add or modify
- ALWAYS backup database before schema changes
- ALL migrations must be tested on copy of production data
- NEVER modify existing data without validation scripts

### Database Operations
- Use parameterized queries to prevent SQL injection
- Implement proper connection pooling and cleanup
- Use transactions for multi-step operations
- Include conflict resolution for upsert operations
- Log database operations with timing information
- Handle database connection failures gracefully
- ALL database operations must use connection pooling
- NEVER open connections without proper cleanup (use context managers)
- ALWAYS use bulk operations for inserting multiple records

## PERFORMANCE STANDARDS

### Scraping Performance
- NEVER scrape without progress tracking for operations > 30 seconds
- ALWAYS implement request timeouts (30 seconds max)

### Database Performance
- ALL queries must have appropriate indexes for expected usage patterns
- NEVER commit without checking query performance impact
- Use appropriate indexes for query patterns
- Implement proper query optimization
- Use connection pooling
- Monitor query execution times
- Use bulk operations when possible
- Implement proper transaction boundaries

### Memory Management
- ALL large datasets must be processed in streaming fashion
- NEVER load entire datasets into memory at once
- ALWAYS clean up resources (connections, files, etc.)
- ALL long-running operations must have memory monitoring
- NEVER create memory leaks in data processing pipelines
- Use context managers for resource management
- Use streaming for large data processing
- Monitor memory usage in production

### Application Performance
- Use generators for large datasets
- Use appropriate data structures (sets for lookups, lists for ordering)
- Implement caching for frequently accessed data
- Profile code for performance bottlenecks
- Optimize I/O operations
- Use asynchronous processing when appropriate

## SECURITY STANDARDS

### Data Protection
- ALL sensitive data must use environment variables
- NEVER hardcode database credentials or API keys
- ALWAYS validate and sanitize external data inputs
- ALL database queries must use parameterized statements
- NEVER log sensitive information in plain text
- Never log sensitive data (passwords, API keys)
- Implement proper input validation

### Authentication & Authorization
- ALL database connections must use secure authentication
- NEVER use default or weak passwords
- ALWAYS validate user inputs for injection attacks
- ALL API endpoints must have proper authentication
- NEVER expose internal system details in error messages
- Use proper authentication for database connections
- Implement rate limiting for API calls
- Use HTTPS for all external communications
- Validate SSL certificates
- Monitor for suspicious activity

## TESTING STANDARDS

### Unit Testing Requirements
- ALL new functions must have corresponding unit tests
- NEVER commit code without tests - minimum 85% coverage
- ALWAYS test both success and failure scenarios
- ALL database operations must be tested with mock connections
- NEVER use production database for testing
- ALL new modules must have comprehensive unit tests
- NEVER mock what you don't own (external APIs, databases)
- ALWAYS test edge cases and error conditions
- ALL tests must be fast (< 1 second each)
- NEVER write tests that depend on external services

### Integration Testing
- ALL CLI commands must have integration tests
- NEVER skip testing of database operations
- ALWAYS test with realistic data volumes
- ALL scrapers must be tested with mock HTTP responses
- NEVER commit without testing complete workflows
- Test database operations with actual database
- Test web scraping with mock responses
- Test end-to-end data flow
- Use test fixtures for consistent data
- Test error scenarios and edge cases

### Validation Testing
- ALL migration phases must have validation tests
- NEVER assume equivalence - always verify with known data
- ALWAYS test with edge cases (multi-team players, missing data)
- ALL performance claims must be verified with benchmarks
- NEVER deploy without comprehensive validation

### Test Data Management
- Use realistic but anonymized test data
- Create test fixtures for common scenarios
- Implement data factories for test object creation
- Use separate test databases
- Clean up test data after each test

## LOGGING AND MONITORING

### Logging Standards
- ALL operations must use structured logging with context
- NEVER use print statements - use proper logging levels
- ALWAYS include relevant metadata in log messages (player_name, season, etc.)
- ALL errors must be logged with full context and stack traces
- NEVER log sensitive information (passwords, API keys)
- Use structured logging with consistent format
- Include context information (user, session, request ID)
- Log at appropriate levels (DEBUG, INFO, WARNING, ERROR)
- Include timing information for operations
- Use correlation IDs for tracking requests

### Performance Monitoring
- ALL scraping operations must record timing and success rates
- NEVER ignore performance regressions > 5%
- ALWAYS monitor memory usage during large operations
- ALL database queries must have performance monitoring
- NEVER deploy without baseline performance metrics
- Track key metrics (requests per second, error rates)
- Monitor database performance and connection usage
- Set up alerts for critical failures
- Track data quality metrics
- Monitor resource usage (CPU, memory, disk)

### Alerting
- ALL critical failures must generate alerts
- NEVER ignore recurring error patterns
- ALWAYS monitor data quality metrics
- ALL performance degradation must trigger investigation
- NEVER let quality issues accumulate

## REFACTORING SPECIFIC RULES

### Code Consolidation
- WHEN combining multiple scripts, ALWAYS preserve all functionality
- NEVER delete old scripts until new CLI commands are proven equivalent
- ALWAYS create mapping document showing old script → new command
- ALL consolidated code must maintain or improve performance
- NEVER introduce regressions during consolidation

### Configuration Management
- ALL configuration must be centralized in src/config/settings.py
- NEVER duplicate configuration values across modules
- ALWAYS provide sensible defaults for optional settings
- ALL configuration changes must be backwards compatible
- NEVER hardcode environment-specific values

### Legacy Support
- ALL legacy scripts must continue working until Phase 4
- NEVER remove legacy functionality without replacement
- ALWAYS provide migration path for existing users
- ALL breaking changes must be clearly documented
- NEVER surprise users with sudden workflow changes

## DOCUMENTATION STANDARDS

### Code Documentation
- ALL modules must have comprehensive README sections
- NEVER omit examples in function docstrings
- ALWAYS document complex algorithms and business logic
- ALL configuration options must be documented
- NEVER assume users understand domain-specific concepts

### User Documentation
- ALL CLI commands must have help text with examples
- NEVER create commands without usage documentation
- ALWAYS provide troubleshooting guides for common issues
- ALL migration steps must be documented for users
- NEVER assume users can figure out new workflows

### Development Documentation
- ALL architecture decisions must be documented
- NEVER make significant changes without updating docs
- ALWAYS maintain API documentation for internal modules
- ALL testing procedures must be documented
- NEVER leave future developers guessing about design choices

## FILE ORGANIZATION

### Directory Structure
```
pfr-qb-scraper/
├── src/
│   ├── cli/               # CLI command handlers
│   ├── core/              # Core business logic
│   ├── operations/        # High-level operations
│   ├── scrapers/          # Web scraping modules
│   ├── database/          # Database operations
│   ├── models/            # Data models and schemas
│   ├── utils/             # Utility functions
│   └── config/            # Configuration files
├── sql/                   # SQL schemas and migrations
├── tests/                 # Test files
├── docs/                  # Documentation
├── scripts/               # Legacy utility scripts
└── legacy/                # Deprecated scripts (Phase 4)
```

### Naming Conventions
- Files: snake_case (e.g., `qb_stats_scraper.py`)
- Classes: PascalCase (e.g., `QBStatsScraper`)
- Functions: snake_case (e.g., `get_qb_stats`)
- Constants: UPPER_SNAKE_CASE (e.g., `MAX_RETRIES`)
- Database tables: snake_case (e.g., `qb_stats`)
- Database columns: snake_case (e.g., `player_name`)

## CONTINUOUS INTEGRATION RULES

### Pre-commit Requirements
- ALL code must pass linting (flake8, black, isort)
- NEVER commit code that doesn't pass type checking
- ALWAYS run tests before committing
- ALL commits must have meaningful messages
- NEVER commit secrets or sensitive data

### Build Pipeline
- ALL builds must include comprehensive testing
- NEVER deploy without passing all quality gates
- ALWAYS include security scanning in pipeline
- ALL performance regressions must be caught by CI
- NEVER merge without code review approval

### Quality Gates
- ALL modules must maintain minimum 85% test coverage
- NEVER merge code that reduces overall test coverage
- ALWAYS validate that new code follows project patterns
- ALL database migrations must be tested in CI
- NEVER skip quality checks for "urgent" changes

## SPECIFIC ANTI-PATTERNS TO AVOID

### Code Smells
- NEVER create god classes with > 10 methods
- AVOID functions with > 50 lines or > 5 parameters
- NEVER use global variables for state management
- AVOID deep nesting (> 3 levels)
- NEVER duplicate code - create shared utilities

### Architecture Violations
- NEVER put database queries in CLI command handlers
- AVOID tight coupling between modules
- NEVER create circular imports
- AVOID exposing internal implementation details
- NEVER bypass the established configuration system

### Migration Mistakes
- NEVER break existing functionality during migration
- AVOID big-bang changes - always incremental
- NEVER skip validation steps
- AVOID feature creep during migration
- NEVER ignore backwards compatibility requirements

## CODE REVIEW GUIDELINES

### Review Checklist
- [ ] Code follows project style guidelines
- [ ] All functions have proper docstrings
- [ ] Error handling is comprehensive
- [ ] Tests are included and passing
- [ ] Performance considerations are addressed
- [ ] Security best practices are followed
- [ ] Database operations are optimized
- [ ] Logging is appropriate and helpful
- [ ] Migration phase requirements are met
- [ ] Backwards compatibility is maintained

### Common Issues to Watch For
- Missing error handling for external API calls
- Improper rate limiting implementation
- SQL injection vulnerabilities
- Missing data validation
- Inefficient database queries
- Memory leaks in long-running processes
- Missing logging for debugging
- Hardcoded configuration values
- Breaking existing functionality during migration

## DEVELOPMENT WORKFLOW

### Git Workflow
- Use meaningful commit messages
- Keep commits focused and atomic
- Use branch names that describe the feature/fix
- Include issue numbers in commit messages
- Review code before merging
- Use semantic versioning for releases

### Code Quality Tools
- Use pylint/flake8 for Python linting
- Use black for code formatting
- Use mypy for type checking
- Use pytest for testing
- Use pre-commit hooks for automated checks
- Use coverage tools to track test coverage

## ENVIRONMENT-SPECIFIC RULES

### Development Environment
- Use debug logging levels
- Include additional validation checks
- Use local databases for testing
- Mock external API calls
- Include timing information in logs

### Production Environment
- Use appropriate logging levels (INFO and above)
- Implement proper monitoring and alerting
- Use connection pooling for databases
- Include health check endpoints
- Implement graceful shutdown procedures
- Use proper error reporting

## RULE CONFLICTS AND FLEXIBILITY

### Phase-Based Rule Application
Rules apply with varying strictness based on migration phase:
- **Phase 1 (Foundation)**: Relaxed standards for bridge code, 60% test coverage minimum
- **Phase 2 (Core)**: Moderate standards for functional equivalence, 70% test coverage minimum  
- **Phase 3 (Advanced)**: Higher standards for advanced features, 80% test coverage minimum
- **Phase 4 (Production)**: Full compliance required, 85% test coverage minimum

### Conflict Resolution
When rules conflict, see `.cursor/rules/conflict-resolution.mdc` for guidance:
- Mock at application boundaries, not deep in external libraries
- Use environment-specific configurations (fast tests, respectful production rate limiting)
- Apply facade patterns for backwards compatibility during migration
- Prioritize: Security > Data Integrity > Backwards Compatibility > Performance > Code Quality

### Rule Priority Hierarchy
1. **Security** (never compromise)
2. **Data integrity** (never compromise)
3. **Backwards compatibility** (Phases 1-3 only)
4. **Functional correctness**
5. **Performance**
6. **Code quality** 
7. **Documentation** (lowest priority during migration)

## ENFORCEMENT

These rules are enforced through:
- Pre-commit hooks for automated checking
- Code review requirements
- Continuous integration pipeline
- Regular code quality audits
- Migration phase gate reviews
- Automated linting and type checking
- Comprehensive test suites

Violations should be caught early and addressed immediately to maintain project quality and migration success.

**See `.cursor/rules/` directory for detailed guidance on:**
- Migration process guardrails
- Python and SQL quality standards
- Testing requirements and strategies
- CLI-specific development patterns
- Anti-patterns to avoid
- Conflict resolution strategies
- Enforcement mechanisms

Remember: The goal is to transform scattered scripts into a professional, maintainable CLI tool while preserving all existing functionality and maintaining the highest code quality standards.